{"title":"Keras学习之Model方法","date":"2020-04-26T17:23:17.000Z","date_formatted":{"ll":"2020年4月27日","L":"2020/04/27","MM-DD":"04-27"},"link":"2020/04/27/Keras学习之Model方法","comments":true,"tags":["Keras"],"categories":["深度学习小技巧"],"updated":"2020-04-26T17:23:17.000Z","content":"<p>在学习深度学习的时候，Keras逐渐成了我最喜欢使用的深度学习框架，因为用它搭建模型很方面，而且相比较Tensorflow来说要容易很多。</p>\n<p>因为也是一个初学者，经常会遇到很多不会的方法，所以难免需要查询官方文档进行学习。学习任何东西都是一个从陌生到熟悉的过程，因此想在博客里新开一个tag，专门放置一些我刚遇到的还不太会使用的方法，也方便以后学习。</p>\n<p>今天这篇博客的话，主要是学习Keras中Model这个方法的使用，文中的例子来自Keras的<a href=\"https://keras-cn.readthedocs.io/en/latest/legacy/models/model/#model\" target=\"_blank\">官方文档</a>，如果感兴趣的话，可以直接点击蓝色的超链接进行学习。</p>\n<h3 id=\"keras的泛型模型接口\">Keras的泛型模型接口<a title=\"#keras的泛型模型接口\" href=\"#keras的泛型模型接口\"></a></h3>\n<p>Keras的泛型模型<code>Model</code>, 即广义的拥有输入和输出的模型，我们使用Model来初始化一个泛型模型：</p>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">from keras.models <span class=\"built_in\">import</span> Model</span><br><span class=\"line\">from keras.layers <span class=\"built_in\">import</span> Input, Dense</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">a</span> = Input(<span class=\"attr\">shape=(32,</span> ))</span><br><span class=\"line\"><span class=\"attr\">b</span> = Dense(<span class=\"number\">32</span>)(a)</span><br><span class=\"line\"><span class=\"attr\">model</span> = Model(<span class=\"attr\">input=a,</span> <span class=\"attr\">output=b)</span></span><br></pre></td></tr></table></figure>\n<p>在这里，我们的模型以<code>a</code>为输入，以<code>b</code>为输出，同样我们可以构造拥有多输入和多输出的模型：</p>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">model = <span class=\"constructor\">Model(<span class=\"params\">input</span>=[<span class=\"params\">a1</span>, <span class=\"params\">a2</span>], <span class=\"params\">output</span>=[<span class=\"params\">b1</span>, <span class=\"params\">b2</span>, <span class=\"params\">b3</span>])</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"常用的model属性\">常用的Model属性<a title=\"#常用的model属性\" href=\"#常用的model属性\"></a></h3>\n<ul>\n<li><code>model.layers</code>：组成模型图的各个层</li>\n<li><code>model.inputs</code>：模型的输入张量列表</li>\n<li><code>model.outputs</code>：模型的输出张量列表</li>\n</ul>\n<h3 id=\"model模型方法\">Model模型方法<a title=\"#model模型方法\" href=\"#model模型方法\"></a></h3>\n<p><strong>compile</strong></p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">compile(self, optimizer, loss, metrics=[], <span class=\"attribute\">loss_weights</span>=None, <span class=\"attribute\">sample_weight_model</span>=None)</span><br></pre></td></tr></table></figure>\n<p>本函数<strong>编译模型以供训练</strong>，参数有：</p>\n<ul>\n<li>optimizer：优化器，为预定义优化器名或优化器对象</li>\n<li>loss：目标函数，为预定义损失函数名或者一个目标函数</li>\n<li>metrics：列表， 包含评估模型在训练和测试时的性能指标，典型用法是<code>metrics=['accuracy']</code>。如果要在多输出模型中为不同的输出指定不同的指标，可向该参数传递一个字典，例如<code>metrics={'output_a': 'accuracy'}</code></li>\n<li>sample_weight_mode：如果你需要按时间步为样本赋权（2D权矩阵），将该值设为“temporal”。默认为“None”，代表按样本赋权（1D权）。如果模型有多个输出，可以向该参数传入指定sample_weight_mode的字典或列表。在下面<code>fit</code>函数的解释中有相关的参考内容。</li>\n<li>kwargs：使用TensorFlow作为后端请忽略该参数，若使用Theano作为后端，kwargs的值将会传递给 K.function</li>\n</ul>\n<h3 id=\"fit\">fit<a title=\"#fit\" href=\"#fit\"></a></h3>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fit(self, x, y, <span class=\"attribute\">batch_size</span>=32, <span class=\"attribute\">np_epoch</span>=10, <span class=\"attribute\">verbose</span>=1, callbacks=[], <span class=\"attribute\">validation_split</span>=0.0, <span class=\"attribute\">validation_data</span>=None, <span class=\"attribute\">shuffle</span>=<span class=\"literal\">True</span>, <span class=\"attribute\">class_weight</span>=None, <span class=\"attribute\">sample_weight</span>=None)</span><br></pre></td></tr></table></figure>\n<p>本函数<strong>用以训练模型</strong>，参数有：</p>\n<ul>\n<li>x：输入数据。如果模型只有一个输入，那么x的类型是numpy array，如果模型有多个输入，那么x的类型应当为list，list的元素是对应于各个输入的numpy array。</li>\n<li>y：标签， numpy array。如果模型有多个输出，可以传入一个numpy array的list。如果模型的输出拥有名字，则可以传入一个字典，将输出名与其标签对应起来。</li>\n<li>batch_size：整数，指定进行梯度下降时每个batch包含的样本数。训练时一个batch的样本会被计算一次梯度下降，使目标函数优化一步。</li>\n<li>np_epoch：整数，训练的轮数，训练数据将会被遍历nb_epoch次。Keras中nb开头的变量均为&quot;number of&quot;的意思。</li>\n<li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录。</li>\n<li>callbacks：list，其中的元素是<code>keras.callbacks.Callback</code>的对象。这个list中的回调函数将会在训练过程中的适当时机被调用。</li>\n<li>validation_split：0~1之间的浮点数，用来<strong>指定训练集的一定比例数据作为验证集</strong>。验证集将不参与训练，并在每个epoch结束后测试的模型的指标，如损失函数、精确度等。</li>\n<li>validation_data：形式为（X，y）或（X，y，sample_weights）的tuple，是指定的验证集。此参数将覆盖validation_spilt。</li>\n<li>class_weight：字典，将不同的类别映射为不同的权值，该参数用来在训练过程中调整损失函数（只能用于训练）。该参数在处理非平衡的训练数据（某些类的训练样本数很少）时，可以使得损失函数对样本数不足的数据更加关注。</li>\n<li>sample_weight：权值的numpy array，用于在训练时调整损失函数（仅用于训练）。可以传递一个1D的与样本等长的向量用于对样本进行1对1的加权，或者在面对时序数据时，传递一个的形式为（samples，sequence_length）的矩阵来为每个时间步上的样本赋不同的权。这种情况下请确定在编译模型时添加了<code>sample_weight_mode='temporal'</code>。</li>\n</ul>\n<p><code>fit</code>函数返回一个<code>History</code>对象，其<code>History.history</code>属性，记录了损失函数和其他指标的数值随epoch变化的情况，如果有验证集的话，也包含了验证集的这些指标的变化情况。</p>\n<h3 id=\"evaluate\">evaluate<a title=\"#evaluate\" href=\"#evaluate\"></a></h3>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate(self, x, y, <span class=\"attribute\">batch_size</span>=32, <span class=\"attribute\">verbose</span>=1, <span class=\"attribute\">sample_weight</span>=None)</span><br></pre></td></tr></table></figure>\n<p>本函数按batch计算<strong>在某些输入数据上模型的误差</strong>，其参数有：</p>\n<ul>\n<li>x：输入数据，与<code>fit</code>一样，是numpy array或numpy array的list。</li>\n<li>y：标签，numpy array。</li>\n<li>batch_size：整数，含义同<code>fit</code>的同名参数。</li>\n<li>verbose：含义同<code>fit</code>的同名参数，但只能取0或1。</li>\n<li>sample_weight：numpy array，含义同<code>fit</code>的同名参数。</li>\n</ul>\n<p>本函数返回一个测试误差的标量值（如果模型没有其他评价指标），或一个标量的list（如果模型还有其他的评价指标）。<code>model.metrics_names</code>将给出list中各个值的含义。</p>\n<h3 id=\"predict\">predict<a title=\"#predict\" href=\"#predict\"></a></h3>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predict(self, x, <span class=\"attribute\">batch_size</span>=32, <span class=\"attribute\">verbose</span>=0)</span><br></pre></td></tr></table></figure>\n<p>本函数按batch获得<strong>输入数据对应的输出</strong>，其参数有：</p>\n<p>函数的返回值是预测值的numpy array</p>\n<h3 id=\"fit_generator\">fit_generator<a title=\"#fit_generator\" href=\"#fit_generator\"></a></h3>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">fit<span class=\"constructor\">_generator(<span class=\"params\">self</span>, <span class=\"params\">generator</span>, <span class=\"params\">sample_per_epoch</span>, <span class=\"params\">nb_epoch</span>, <span class=\"params\">verbose</span>=1, <span class=\"params\">callbacks</span>=[], <span class=\"params\">validation_data</span>=None, <span class=\"params\">nb_val_samples</span>=None, <span class=\"params\">class_weight</span>=&#123;&#125;, <span class=\"params\">max_q_size</span>=10)</span></span><br></pre></td></tr></table></figure>\n<p>利用Python的生成器，<strong>逐个生成数据的batch并进行训练</strong>。生成器与模型将并行执行以提高效率。</p>\n<p>函数的参数是：</p>\n<ul>\n<li>generator：生成器函数，生成器的输出应该为：\n<ul>\n<li>一个形如（inputs，targets）的tuple</li>\n<li>一个形如（inputs, targets,sample_weight）的tuple。所有的返回值都应该包含相同数目的样本。生成器将无限在数据集上循环。每个epoch以经过模型的样本数达到<code>samples_per_epoch</code>时，记一个epoch结束</li>\n</ul>\n</li>\n<li>samples_per_epoch：整数，当模型处理的样本达到此数目时计一个epoch结束，执行下一个epoch</li>\n<li>verbose：日志显示，0为不在标准输出流输出日志信息，1为输出进度条记录，2为每个epoch输出一行记录</li>\n<li>validation_data：具有以下三种形式之一\n<ul>\n<li>生成验证集的生成器</li>\n<li>一个形如（inputs,targets）的tuple</li>\n<li>一个形如（inputs,targets，sample_weights）的tuple</li>\n</ul>\n</li>\n<li>nb_val_samples：仅当<code>validation_data</code>是生成器时使用，用以限制在每个epoch结束时用来验证模型的验证集样本数，功能类似于<code>samples_per_epoch</code></li>\n<li>max_q_size：生成器队列的最大容量</li>\n</ul>\n<p>函数返回一个<code>History</code>对象。</p>\n<p>一个简单的例子。</p>\n<figure class=\"highlight pgsql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def generate_arrays_from_file(<span class=\"type\">path</span>):</span><br><span class=\"line\">    <span class=\"keyword\">while</span> <span class=\"number\">1</span>:</span><br><span class=\"line\">    f = <span class=\"keyword\">open</span>(<span class=\"type\">path</span>)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> <span class=\"type\">line</span> <span class=\"keyword\">in</span> f：</span><br><span class=\"line\">        # <span class=\"keyword\">create</span> numpy <span class=\"keyword\">array</span> <span class=\"keyword\">of</span> <span class=\"keyword\">input</span> data</span><br><span class=\"line\">        # <span class=\"keyword\">and</span> labels, <span class=\"keyword\">from</span> <span class=\"keyword\">each</span> <span class=\"type\">line</span> <span class=\"keyword\">in</span> the file</span><br><span class=\"line\">        x, y = process_line(<span class=\"type\">line</span>)</span><br><span class=\"line\">        yield(x, y)</span><br><span class=\"line\">     f.<span class=\"keyword\">close</span>()</span><br><span class=\"line\">     </span><br><span class=\"line\">model.fit_generator(generate_arrays_from_file(<span class=\"string\">'/my_file.txt'</span>),samples_per_epoch=<span class=\"number\">10000</span>, nb_epoch=<span class=\"number\">10</span>)</span><br></pre></td></tr></table></figure>\n<h3 id=\"evaluate_generator\">evaluate_generator<a title=\"#evaluate_generator\" href=\"#evaluate_generator\"></a></h3>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">evaluate<span class=\"constructor\">_generator(<span class=\"params\">self</span>, <span class=\"params\">generator</span>, <span class=\"params\">val_samples</span>, <span class=\"params\">max_q_size</span>=10)</span></span><br></pre></td></tr></table></figure>\n<p>本函数使用一个生成器作为数据源，来评估模型，生成器应返回与<code>test_on_batch</code>的输入数据相同类型的数据。</p>\n<p>函数的参数是：</p>\n<ul>\n<li>generator：生成输入batch数据的生成器</li>\n<li>val_samples：生成器应该返回的总样本数</li>\n<li>max_q_size：生成器队列的最大容量</li>\n<li>nb_worker：使用基于进程的多线程处理时的进程数</li>\n<li>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</li>\n</ul>\n<h3 id=\"predict_generator\">predict_generator<a title=\"#predict_generator\" href=\"#predict_generator\"></a></h3>\n<figure class=\"highlight reasonml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">predict<span class=\"constructor\">_generator(<span class=\"params\">self</span>, <span class=\"params\">generator</span>, <span class=\"params\">val_samples</span>, <span class=\"params\">max_q_size</span>=10, <span class=\"params\">nb_worker</span>=1, <span class=\"params\">pickle_safe</span>=False)</span></span><br></pre></td></tr></table></figure>\n<p>从一个生成器上获取数据并进行预测，生成器应返回与<code>predict_on_batch</code>输入类似的数据。</p>\n<p>函数的参数是：</p>\n<ul>\n<li>generator：生成输入batch数据的生成器</li>\n<li>val_samples：生成器应该返回的总样本数</li>\n<li>max_q_size：生成器队列的最大容量</li>\n<li>nb_worker：使用基于进程的多线程处理时的进程数</li>\n<li>pickle_safe：若设置为True，则使用基于进程的线程。注意因为它的实现依赖于多进程处理，不可传递不可pickle的参数到生成器中，因为它们不能轻易的传递到子进程中。</li>\n</ul>\n<hr>\n","next":{"title":"Image hashing with OpenCV and Python","link":"2020/04/22/Image-hashing-with-OpenCV-and-Python"},"plink":"https://musicpoet.top/2020/04/27/Keras学习之Model方法/","toc":[{"id":"keras的泛型模型接口","title":"Keras的泛型模型接口","index":"1"},{"id":"常用的model属性","title":"常用的Model属性","index":"2"},{"id":"model模型方法","title":"Model模型方法","index":"3"},{"id":"fit","title":"fit","index":"4"},{"id":"evaluate","title":"evaluate","index":"5"},{"id":"predict","title":"predict","index":"6"},{"id":"fit_generator","title":"fit_generator","index":"7"},{"id":"evaluate_generator","title":"evaluate_generator","index":"8"},{"id":"predict_generator","title":"predict_generator","index":"9"}],"copyright":{"author":"打马诗人","license":"Attribution-NonCommercial-NoDerivatives 4.0 International<br>(<a href=\"https://creativecommons.org/licenses/by-nc-sa/4.0/\" rel=\"external nofollow noopener\" target=\"_blank\">CC BY-NC-ND 4.0</a>)","published":"2020年4月27日","updated":"2020年4月27日"}}