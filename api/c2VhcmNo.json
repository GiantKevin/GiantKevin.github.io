[{"title":"Image hashing with OpenCV and Python","date":"2020-04-22T05:51:32.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"updated":"2020-04-22T05:51:32.000Z","content":"\n写在前面：这篇文章摘自Adrian Rosebrock的一篇技术博客，这里只做简单的翻译总结。如果想直接看原文的话，可以点击以下链接查看：Image hashing with OpenCV and Python\n\n\nImage hashing 或者 perceptual hashing 的过程包括：\n\n检测一张图片的内容\n根据输入图片的内容，为它创建一个特殊的hash值\n\n或许最出名的Image hashing 工具/服务是TinEye，它是一个逆向的图片搜索引擎。\n使用TinEye, 用户可以：\n\n上传一张图片\nTinEye会告诉用户网上这张图片的出处\n\n在这节的开头，你可以看到一个可视化的perceptual hashing/image hashing的例子。\n对于一张给定的输入图片，我们的算法会根据图像的视觉表现来计算图片的hash值。同时外观相似的图像，也应该有尽可能相似的hash值。（这里相似是指hash值之间的Hamming距离）\n通过使用image hashing 算法，我们可以在一定的时间内找到近似的图片。其中最差的情况是，我们需要遍历整个数据结构，时间复杂度是O(lg n)。\n这里做个提醒，通过这篇文章我们会：\n\n讨论image hashing/perceptual hashing(和为什么传统的hash不奏效)\n实现image hashing， 特别是difference hashing(dHash)\n使用image hashing来解决现实世界中的问题\n\nStep #1: 将图片转化为灰度图\n","plink":"https://musicpoet.top/2020/04/22/Image-hashing-with-OpenCV-and-Python/"},{"title":"OOP设计7大设计原则总结","date":"2020-04-09T09:07:24.000Z","date_formatted":{"ll":"2020年4月9日","L":"2020/04/09","MM-DD":"04-09"},"updated":"2020-04-09T09:07:24.000Z","content":"在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。下面将为你依次介绍这7条开发原则。\n一. 开闭原则\n\n\n定义\n软件实体应当对扩展开放，对修改关闭。当应用需求改变时，在不修改软件实体源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。\n\n\n作用\n\n\n对软件测试的影响。软件遵循开闭原则的话，软件测试只需要对扩展的代码进行测试就好了，因为原来的测试代码可以正常运行。\n\n\n可以提高代码的可复用性。粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。\n\n\n可以提高代码的可维护性。遵循开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。\n\n\n\n\n实现方法\n可以通过“抽象约束、封装变化”来实现开闭原则。即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，从而将相同的可变因素封装在相同的具体实现类中。\n因为抽象灵活性好、适应性广，只要抽象地合理，可以基本保持软件架构的稳定。而软件中容易改变的细节可以从抽象派生的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。\n\n\n二.里氏代换原则（LSP原则）\n\n\n定义\n继承必须确保超类所拥有的性质在子类中仍然成立。它是继承复用的基础，也反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。\n\n\n作用\n\n里氏替换原则是实现开闭原则的重要方式之一。\n它克服了继承中重写父类造成的可复用性变差的缺点。\n它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。\n\n\n\n实现方法\n里氏替换原则通俗来说就是：**子类可以扩展父类的功能，但是不能改变父类原有的功能。**子类继承父类时，除了添加新的方法完成新增的功能外，尽量不要重写父类的方法。\n如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的复用性会变差，特别是运行多态比较频繁时，程序运行出错的概率会非常大。\n如果程序违背了里氏替换原则，继承类的对象在基类出现的地方那个会出现运行错误。修正方法是：取消原来的继承关系，重新设计它们之间的关系。\n\n\n三. 依赖倒置原则\n\n\n定义\n高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。\n核心思想：要面向接口编程，不要面向实现编程。\n依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。而使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。\n\n\n作用\n\n可以降低类之间的耦合性。\n可以提高系统的稳定性。\n可以减少并行开发引起的风险。\n可以提高代码的可读性和可维护性。\n\n\n\n实现方法\n我们在具体编程中只要遵循以下4点，就能在项目中满足这个规则：\n\n每个类尽量提供接口或抽象类，或者两者都具备。\n变量的声明类型尽量是接口或者抽象类。\n任何类都不应该从具体类派生。\n使用继承时尽量遵循里氏替换原则。\n\n\n\n四. 单一职责原则\n\n\n定义\n一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。\n该原则提出对象不应该承担太多职责，如果一个对象承担太多的职责，至少会有以下两个缺点：\n\n一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力。\n当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。\n\n\n\n作用\n\n降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。\n提高类的可读性。复杂性降低，自然其可读性会提高。\n提高系统的可维护性。可读性提高，那自然更容易维护了。\n\n\n\n实现方法\n单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。\n\n\n五.接口隔离原则(ISP)\n\n\n定义\n程序员应尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口只包含客户感兴趣的方法。一个类对另一个类的依赖应该建立在最小的接口之上。\n\n\n接口隔离原则和单一职责原则的区别\n\n单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。\n单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。\n\n\n\n作用\n\n将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。\n接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。\n如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。\n使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。\n能减少项目工程中的代码冗余。\n\n\n\n实现方法\n\n接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。\n为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。\n了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。\n提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。\n\n\n\n六.迪米特法则\n\n\n定义\n只与你“直接朋友”交谈，不跟“陌生人”说话。\n迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。\n如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。\n\n\n作用\n\n\n降低了类之间的耦合度，提高了模块的相对独立性。\n\n\n由于亲合度降低，从而提高了类的可复用率和系统的扩展性。\n\n\n注：过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。\n\n\n实现方法\n\n\n从依赖者的角度来说，只依赖应该依赖的对象。\n\n\n从被依赖者的角度说，只暴露应该暴露的方法。\n\n\n\n\n使用迪米特法则应注意的点\n\n\n在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。\n\n\n在类的结构设计上，尽量降低类成员的访问权限。\n\n\n在类的设计上，优先考虑将一个类设置成不变类。\n\n\n在对其他类的引用上，将引用其他对象的次数降到最低。\n\n\n不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。\n\n\n谨慎使用序列化（Serializable）功能。\n\n\n\n\n七.合成复用原则(CRP)\n\n\n定义\n在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。如果要使用继承关系，必须得严格遵循里氏替换原则。\n\n\n作用及重要性\n通常类的复用分为继承复用和合成复用两种。继承复用虽然简单易实现，但是它也有很多缺点：\n\n\n继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。\n\n\n子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。\n\n\n它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。\n\n\n采用组合或者聚合复用时，则可避免这些缺点，同时也具备以下优点：\n\n维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。\n新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。\n复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。\n\n3.实现方法\n通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。\n\n\n八.总结\n以上介绍的7种设计原则是软件设计模式必须遵循的原则，各种原则要求的侧重点不同。\n\n\n开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。\n\n\n里氏替换原则告诉我们不要破坏继承体系。\n\n\n依赖倒置原则告诉我们要面向接口编程。\n\n\n单一职责原则告诉我们实现类要职责单一。\n\n\n接口隔离原则告诉我们在设计接口的时候要精简单一。\n\n\n迪米特法则告诉我们要降低耦合度。\n\n\n合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。\n\n\n\n以上内容整理自 C语言中文网 ，感谢你的阅读。\n","plink":"https://musicpoet.top/2020/04/09/OOP设计7大设计原则总结/"},{"title":"针对Github下载速度过慢的解决办法","date":"2020-03-25T14:29:42.000Z","date_formatted":{"ll":"2020年3月25日","L":"2020/03/25","MM-DD":"03-25"},"updated":"2020-03-25T14:29:42.000Z","content":"对于一个程序员来说，逛Github可以说是一件必不可少的事情，毕竟这是全球最大的~~“同性交友网站”~~程序员交流网站。我们也会经常看到一些感兴趣的项目，于是便想着下载下来研究。经常困扰我们的一个问题就是，从Github上下载项目实在是太慢了，每秒十几kb的下载速度让人抓狂，实在是太太太太太慢了。于是便想着有没有什么办法可以提高下载速度，从网上搜索了一番，发现了可以借助**”码云“**间接下载Github上的项目。\n接下来，我就简单介绍一下用&quot;码云&quot;下载Github项目的流程。\n1.注册码云\n首先简单介绍一下&quot;码云&quot;这个网站吧，它是码云是开源中国社区2013年推出的基于 Git 的代码托管服务，目前已经成为国内最大的代码托管平台，致力于为国内开发者提供优质稳定的托管服务。(摘自官方介绍) 简单来说，它和Github的性质是一样的，只是它的服务器在国内，访问和下载速度会相对快很多。\n首先贴上”码云“官方网站的链接：码云 。\n打开网站之后，在网站右上角有&quot;注册&quot;按钮，鼠标点击进行注册。\n\n注册的时候，尽量使用英文的用户姓名，并且英文名和你的个人码云的地址有关。同时在注册的时候需要验证手机或者邮箱。\n\n2.将你需要下载的仓库，导入自己的码云中\n用注册的账户登录之后，你会看到如下操作界面。在界面的左下角有一个“仓库”的区间，点击**&quot;+&quot;**进行仓库的添加。\n\n&quot;+&quot;点击完毕后，在跳出的界面往下拉，在页面底端会有一个&quot;导入已有仓库&quot;的链接，点击之后在输入框中贴上自己想要导入的库，然后点击创建。\n\n\n导入数据需要花点时间，过了一段时间，系统会提示你导入成功，你会看到你导入的库。点击右上方的&quot;克隆/下载&quot;按钮，便可进行克隆和下载。\n你可以下载ZIP格式的压缩文件，也可以通过复制HTTPS的文件，通过git进行下载。\n\n下载的速度比直接用Github下载快很多，妈妈再也不用担心下大型的项目要花很长时间了。下载速度可以达到3MB每秒，可以说速度还可以了。\n\n\n以上教程来自网络，这里只做记录分享，感谢您的阅读。\n","plink":"https://musicpoet.top/2020/03/25/针对Github下载速度过慢的解决办法/"},{"title":"高级人工智能之通过搜索解决问题","date":"2020-03-20T09:02:14.000Z","date_formatted":{"ll":"2020年3月20日","L":"2020/03/20","MM-DD":"03-20"},"updated":"2020-03-20T09:02:14.000Z","content":"1.人工智能中的问题求解\n\n解：是一个达到目标动作的序列。\n过程：寻找该动作，称其为搜索。\n问题形式化：给定一个目标，决定要考虑的动作与状态。\n为何搜索：对于某些NP完和NP难问题，只能通过搜索来解决。\n问题求解智能体：是一种基于目标的智能体，通过搜索来解决问题。\n\n2.相关术语\n\n状态空间：可以形式化地定义为——初始状态、动作和转换模型。\n图：状态空间形成一个图，其中节点表示状态、链接表示动作。\n路径：状态空间的一条路径是由一系列动作连接的一个状态序列。\n\n3.问题形式化的5个要素\n\n初始状态：智能体出发时的状态。\n动作：描述智能体可执行的动作。\n转换模型：描述每个动作在做什么。\n目标测试：确定一个给定的状态是否为目标状态。\n路径代价：每条路径所分配的一个数值代价。\n\n4.搜索算法\n一种通用的搜索算法\n\n该frontier(也称为open list)：一种数据结构，用于存储所有的叶节点。\n在frontier上扩展结点的过程持续进行，知道找到一个解或者没有其它状态可扩展。\n一种通用的图搜索算法\n\n该explored(也称为closed list)：一种数据结构，用于记忆每个扩展结点。\nexplored和frontier中的结点可以被丢弃。\n5.无信息搜索\n定义：无信息搜索也被称为盲目搜索。该术语(无信息、盲目的)意味着该搜索策略没有超过问题定义提供的状态之外的附加信息。\n所有能做的就是生成后继结点，并且从区分一个目标状态或一个非目标状态。\n所有的搜索策略是由节点扩展的顺序加以区分。这些搜索策略是：宽度优先、深度优先以及一致代价搜索。\n无信息搜索的策略评价\n一种无信息搜索是通过选择结点扩展的顺序来定义的。\n其策略可按照如下特性来评价：\n\n完备性。是否总能找到一个存在的解。\n时间复杂性：花费多长时间找到这个解。\n空间复杂性。需要多少内存。\n最优性：是否总能找到最优的解。\n\n时间复杂性和空间复杂性用如下术语来衡量：\n\nb–搜索树的最大分支因子。\nd–最浅的深度。\nm–搜索树的最大深度。\n\n宽度优先搜索\n搜索策略：扩展最浅的未扩展节点。\n实现方法：使用FIFO(先进先出)队列，即新的后继结点放在后面。\n\n宽度优先搜索不能解决指数复杂性问题，小的分支因子除外。\n一致代价搜索\n搜索策略：扩展最低代价的未扩展节点。\n实现方法：队列，按路径代价排序，最低优先。\n\n深度优先搜索\n搜索策略：扩展最深未扩展节点。\n实现方法：使用LIFO队列，把后继节点放在队列的前端。\n-深度受限搜索\n若状态空间无限，深度优先搜索就会发生失败，这个问题可以用一个预定的深度限制得到解决。\n缺点：\n如果我们选择l &lt; d,即最浅的的目标在深度限制之外，这种方法就会出现额外的不完备性。\n如果我们选择l &gt; d,深度受限搜索也不是最优的。\n\n-迭代加深搜索\n它将深度优先和宽度优先的优势相结合，逐步增加深度限制反复运行直到找到目标。\n它以深度优先搜索相同的顺序访问搜索树的节点，但先访问节点的累积顺序实际是宽度优先。\n\n-双向搜索\n它同时进行两个搜索：一个是从初始状态向前搜索，而另一个则从目标向后搜索。当两者在中间相遇时停止。\n\n该方法可以通过一种剩余距离的启发式估计来导向。\n-无信息搜索树策略评价\n\n6.有信息搜索\n有信息搜索也被称为启发式搜索，这类策略采用超出问题本身定义的、问题特有的知识，因此能够找到比无信息搜索更有效的解。\n一般方法使用如下函数的一个或两者：\n评价函数，记作f(n)，用于选择一个节点进行扩展。\n启发式函数，记作h(n)，作为f的一个组成部分。\n-最佳优先搜索\n搜索策略：一个节点被选择进行扩展是基于一个评价函数，f(n)。大多数的最佳优先搜索算法还包含一个启发式函数，h(n)。\n实现方法：与一致代价搜索相同。然而，最佳优先搜索使用f(n)代替g(n)来整体优先队列。\n启发式函数h(n)：从节点n到目标状态的最低路径估计代价。\n特例：贪婪搜索、A*搜索\n贪婪搜索\n搜索策略：试图扩展最接近目标的节点。\n评价函数：f(n) = h(n)\n它仅使用启发式函数对节点进行评价。\n迭代加深A搜索*\n\n它是迭代加深深度优先搜索的变种，从A*搜索算法借鉴了这一思想，即使用启发式函数来评价到目标的剩余代价。\n\n它是一种深度优先搜索算法，内存使用率低于A*算法。但是，不同于标准的迭代加深搜索，它集中于探索最有希望的节点，因此不会去搜索树任何处的同样深度。\n比较：\n\n迭代加深深度优先搜索：使用搜索深度作为每次迭代的截止值。\n迭代加深A*搜索：使用信息更丰富的评价函数，f(n) = g(n) + h(n)\n\ng(n)：到达该节点的代价    h(n)：该节点到目标的估计代价\n","plink":"https://musicpoet.top/2020/03/20/高级人工智能之通过搜索解决问题/"},{"title":"高级人工智能之智能Agent","date":"2020-03-20T02:09:26.000Z","date_formatted":{"ll":"2020年3月20日","L":"2020/03/20","MM-DD":"03-20"},"updated":"2020-03-20T02:09:26.000Z","content":"1.智能Agent的特点：\n可自主操作、感知环境、持续动作、顺应变化、实现目标和最佳结果(或者最佳预期结果)。\n概括地说，一个智能体可以被看作具有如下功能的任何事物：\n\n通过感受器感知外部环境，并且通过执行器作用于外部环境。\n可以通过学习或者应用知识来实现其目标。\n\n2.理性Agent\n定义：是一个有正确行为的智能体——该功能表中的每个条目都正确填写。\n对于正确行为的解释：\n\n一个智能体在一个环境中依据感知生成一系列的动作。\n这些动作由一系列状态而引起环境发生变化。\n如果该系列变化是所期望的，则该智能体表现良好。\n\n对于理性的理解：\n理性是指探索、学习和自主的。\n理性的动作是指对给定的感知序列，能使期待的性能指标最大化。\n理性同样依赖于四件事：\n\n定义成功标准的性能指标。\n智能体对环境的先验知识。\n智能体所能够完成的动作。\n智能体最新的感知序列。\n\n3.PEAS\n定义：PEAS是一种任务环境的规范，四个大写字母的缩写分别代表Performance(性能)、Environment(环境)、Actuators(动作器)和Sensors(感受器)。\n不同的环境类型：\n\n完全可观测和部分可观测。一个智能体的传感器在每个时间点上可访问环境的完整状态，则该任务环境就是完全可观测的。\n单智能体和多智能体。一个智能体在一个环境内自运行，则它就是一个单智能体。\n确定性和随机性。环境的下一个状态完全由当前的状态和该智能体执行的动作所决定，则该环境是确定的。\n阵发性和连续性。智能体的动作过程被分为原子的片段，并且每个片段的动作选择仅仅依赖于片段本身。\n动态与静态。如果环境随智能体的行为而改变，则该智能体的环境是动态的；否则是静态的。\n离散与连续。离散与连续的区别在于环境的状态、时间处理的方式、以及感知和智能体的动作。\n已知与未知。在一个已知的环境下，所有动作的结果都是给定的。如果环境是未知的，则该智能体将需要学习如何动作，以便于做出正确的决策。\n\n4.智能体的结构\n智能体的结构如下图所示：\n\n智能体的层次：智能体通常表现为一个分层的结构，它包含许多&quot;子智能体&quot;，而子智能体处理和执行较低级的功能。智能体和子智能体构建一个完整的系统，它可以通过行为和反应来完成艰巨的任务。\n表示智能体状态的三种方式：\n\n原子式：每个状态是一个黑盒子，没有内部结构。\n因子式：每个状态由一组固定的属性和值组成。\n结构式：每个状态包含对象，每个具有属性以及与其他对象的关系。\n\n\n5.智能体的主要类别\n下面介绍的5种类型的智能体，体现几乎所有智能系统的基本原理。\n\n简单反射智能体。\n基于模型的反射智能体。\n基于目标的智能体。\n基于效用的智能体。\n学习智能体。\n\n简单反射智能体\n简单反射智能体仅仅在当前感知的基础上动作，忽略其余的感知历史。\n智能体功能是基于条件动作规则：if 条件 then 动作。\n\n关于简单反射智能体：\n\n仅当外部环境为完全可测时，该智能体的功能才能发挥。\n某些反射智能体也可以包含关于其当前状态的信息，允许它们忽视执行器已被触发的条件。\n智能体在部分可观测的环境下运行时，无限循环往往是无法避免的。\n如果智能体可以随机产生其动作，有可能从无限循环中摆脱出来。\n\n模型反射智能体\n一个基于模型的反射智能体可以处理部分可观测环境。\n其当前状态存储在智能体中，维护某种结构，它描述不可见外部环境中的一部分。\n\n关于基于模型反射智能体：\n\n关于&quot;外部环境如何运作&quot;的知识被称为一个外部环境模型，由此得名&quot;基于模型的智能体&quot;。\n基于模型的反射智能体将保持某种内部模型。\n内部模型依赖于感知的历史，因此至少反射某些当前状态无法观测的方面。\n它作为反射智能体以某种方式选择动作。\n\n一个基于模型的反射智能体算法。它采用一个内部模型来保持当前外部环境状态的轨迹，然后用等同于简单反射智能体的方式选择一个动作。\n基于目标智能体\n通过利用&quot;目标&quot;信息，基于目标的智能体进一步扩展了基于模型的智能体的功能。\n\n关于基于目标智能体：\n\n目标信息描述所希望的情形。\n它允许智能体在多个可能性之间选择一种方式，挑选出达到目标状态的那一个。\n搜索和规划是人工智能的子领域，致力于发现达到智能体目标的动作序列。\n在某些情况下，基于目标的智能体似乎不太有效，但是它更为灵活，因为这种支持其决策的知识明显地展示出来，并且可以被修改。\n\n基于效用的智能体\n一个特殊的状态可通过一个效用函数得到，该函数将一个状态隐射到该状态效用的度量。\n\n关于基于效用的智能体：\n\n一种更通用的性能度量，应该根据它们使得智能体多么&quot;高兴&quot;的程度，允许对不同的外部环境状态进行比较。\n效用这个术语，可用于描述智能体是多么高兴。\n一个理性的基于效用的智能体选择动作，将动作的期待效应最大化。\n一个基于效用的智能体需要建模并记录环境、任务轨迹，这涉及大量的感知、表征、推理和学习的研究。\n\n学习智能体\n学习允许智能体最初在未知的环境中运行，并且与其最初的知识相比，会变得越来越胜任。\n\n关于学习智能体：\n\n学习要素：它利用评论者对智能体如何动作的反馈，然后决定应该如何修改性能要素以便于未来做的更好。\n性能要素：获得感知并决定动作。\n问题发生器：它对推荐的动作负责，这将形成新的经验。\n\n智能体的分类法\n\n","plink":"https://musicpoet.top/2020/03/20/高级人工智能之智能Agent/"},{"title":"创建型设计模式","date":"2020-03-16T12:36:04.000Z","date_formatted":{"ll":"2020年3月16日","L":"2020/03/16","MM-DD":"03-16"},"updated":"2020-03-16T12:36:04.000Z","content":"一. 创建型模式的特点与分类\n创建型模式的主要关注点是“怎么创建对象”，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。\n创建型模式主要分为以下几种。\n\n单例模式：某个类只生成一个实例，该类提供一个全局访问点供外部获取该实例，其拓展是有限多例模式。\n原型模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。\n工厂方法模式：定义一个用于创建产品的接口，由子类决定生产什么产品。\n抽象工厂模式：提供一个创建产品族的接口，其每个子类可以产生一系列相关的产品。\n建造者模式：将一个复杂的对象分解成多个相对简单的部分，然后根据不同的需要分别创建它们，最后构建该复杂对象。\n\n以上 5 种创建型模式，除了工厂方法模式属于类创建型模式，其他的全部属于对象创建型模式。\n二.单例模式\n1.单例模式的定义与特点\n定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。\n单例模式有3个特点：\n\n单例类只有一个实例对象。\n该单例对象必须由单例类自行创建。\n单例类对外提供一个访问该单例的全局访问点。\n\n2.单例模式的结构与应用场景\n单例模式的主要角色如下：\n\n单例类：包含一个实例且能自行创建这个实例的类。\n访问类：使用单例的类\n\n应用场景：\n\n某类只要求生成一个对象的时候。\n当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。\n当某类需要频繁实例化，而创建的对象又频繁被销毁的时候。\n\n三.原型模式\n1.原型模式的定义与特点\n定义：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或者相似的新对象。\n特点：在这里，原型实例指定了要创建的对象的种类。用这种方法创建对象非常高效，根本不需要知道创建的细节。\n2.原型模式的结构与应用场景\n原型模式的主要角色如下：\n\n抽象原型类：规定具体原型对象必须实现的接口。\n具体原型类：实现抽象原型类的clone()方法，它是可被复制的对象。\n访问类：使用具体原型类中的clone()方法来复制新的对象。\n\n应用场景：\n\n对象之间相同或者相似，即只是个别的几个属性不同的时候。\n对象的创建过程比较麻烦，但复制比较简单的时候。\n\n四.工厂方法模式\n1.工厂方法模式的定义与特点\n定义：定义一个创建产品对象的工厂接口，将产品对象实际创建工作推迟到具体子工厂类当中。满足创建型模式中要求“创建与使用相分离“的特点。\n我们把创建的对象称为”产品“，把创建产品的对象称为”工厂“。如果要创建的产品不多，只需要一个工厂类就可以完成，这种模式叫”简单工厂模式“，它的缺点是增加新产品时会违背”开闭原则“。\n工厂方法模式的主要优点：\n\n\n用户只需要知道具体工厂的名称就可得到所要的产品，而不需要知道产品的具体创建过程。\n\n\n在系统增加新的产品时，只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则。\n\n\n缺点：\n\n每增加一个产品就要增加一个具体的产品类和一个对应的具体工厂类，增加了系统的复杂度。\n\n2.工厂方法模式的结构与应用场景\n工厂方法模式的主要角色如下：\n\n抽象工厂：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。\n具体工厂：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。\n抽象产品：定义了产品的规范，描述了产品的主要特性和功能。\n具体产品：定义抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。\n\n应用场景：\n\n客户只知道创建产品的工厂名，而不知道具体的产品名。\n创建对象的任务由多个具体子工厂的某一个完成，而抽象工厂只提供创建产品的接口。\n客户不关系创建产品的细节，只关心产品的品牌。\n\n五.抽象工厂模式\n1.抽象工厂模式的定义与特点\n定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类不需要指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。\n抽象工厂模式是工厂方法模式的升级版，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。\n使用抽象工厂模式一般要满足以下条件：\n\n系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。\n系统一次只可能消费其中某一族的产品，即同族的产品一起使用。\n\n抽象工厂模式的主要优点：\n\n可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。\n当增加一个新的产品族时不需要修改源代码，满足开闭原则。\n\n缺点：\n\n当产品族中需要增加一个新产品时，所有的工厂类都需要进行修改。\n\n2.抽象工厂模式的结构与应用场景\n抽象工厂模式的主要角色如下：\n\n\n抽象工厂：提供了创建产品的接口，它包含多个创建产品的方法 ，可以创建多个不同等级的产品。\n\n\n具体工厂：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。\n\n\n抽象产品：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。\n\n\n具体产品：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。\n\n\n应用场景：\n\n\n当需要创建的对象是一系列相互关联或相互依赖的产品族时。\n\n\n系统中有多个产品族，但每次只使用其中的某一族产品。\n\n\n系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。\n\n\n六.建造者模式\n1.建造者模式的定义与特点\n定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为”建造者模式“。它将一个复杂的对象分解为多个简单的对象，然后一步步构建而成，它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。\n建造者模式的主要优点：\n\n各个具体的建造者相互独立，有利于系统的扩展。\n客户端不必知道产品内部组成的细节，便于控制细节风险。\n\n缺点：\n\n产品的组成部分必须相同，这限制了其使用范围。\n如果产品的内部变化复杂，该模式会增加很多建造者类。\n\n建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂模式更注重零部件的创建过程，但两者可以结合使用。\n2.建造者模式的结构与应用场景\n建造者模式的主要角色如下：\n\n\n产品角色：它是包含多个组成部件的复杂对象，由具体建造者来创建其各个滅部件。\n\n\n抽象建造者：它是一个包含创建产品各个子部件的抽象方法的接口，通常还包含一个返回复杂产品的方法 。\n\n\n具体建造者：实现 Builder 接口，完成复杂产品的各个部件的具体创建方法。\n\n\n指挥者：它调用建造者对象中的部件构造与装配方法完成复杂对象的创建，在指挥者中不涉及具体产品的信息。\n\n\n应用场景：\n\n\n创建的对象较复杂，由多个部件构成，各个部件面临着复杂的变化，但构件间的建造顺序是稳定。\n\n\n创建复杂对象的算法独立于该对象的组成部分以及它们的装配方式，即产品的构建过程和最终的表示是独立的。\n\n\n\n以上是对5种创建型模式的简单介绍，文章整理自C语言中心网 ,感谢您的阅读。\n","plink":"https://musicpoet.top/2020/03/16/创建型设计模式/"},{"title":"about","date":"2020-04-09T08:22:00.000Z","date_formatted":{"ll":"2020年4月9日","L":"2020/04/09","MM-DD":"04-09"},"updated":"2020-04-09T08:22:00.000Z","content":"","plink":"https://musicpoet.top/about/"}]