{"title":"Image hashing with OpenCV and Python","date":"2020-04-22T05:51:32.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"link":"2020/04/22/Image-hashing-with-OpenCV-and-Python","comments":true,"tags":["CV"],"categories":["图像处理"],"updated":"2020-04-22T05:51:32.000Z","content":"<blockquote>\n<p>写在前面：这篇文章摘自<strong>Adrian Rosebrock</strong>的一篇技术博客，这里只做简单的翻译总结。如果想直接看原文的话，可以点击以下链接查看：<a href=\"https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/\" target=\"_blank\">Image hashing with OpenCV and Python</a></p>\n</blockquote>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2020/04/9f118c121b0f31be.png\" alt=\"\" class=\"φcx\"></p>\n<p>Image hashing 或者 perceptual hashing 的过程包括：</p>\n<ol>\n<li>检测一张图像的内容</li>\n<li>根据输入图像的内容，为它创建一个特殊的hash值</li>\n</ol>\n<p>或许最出名的Image hashing 工具/服务是<a href=\"https://tineye.com/\" target=\"_blank\">TinEye</a>，它是一个逆向的图像搜索引擎。</p>\n<p>使用TinEye, 用户可以：</p>\n<ol>\n<li>上传一张图片</li>\n<li>TinEye会告诉用户网上这张图片的出处</li>\n</ol>\n<p>在这节的开头，你可以看到一个可视化的perceptual hashing/image hashing的例子。</p>\n<p>对于一张给定的输入图像，我们的算法会根据图像的视觉表现来计算图片的hash值。同时外观<strong>相似</strong>的图像，也应该有尽可能相似的hash值。（这里相似是指hash值之间的Hamming距离）</p>\n<p>通过使用image hashing 算法，我们可以在一定的时间内找到近似的图像。其中最差的情况是，我们需要遍历整个数据结构，时间复杂度是O(lg n)。</p>\n<p>这里做个提醒，通过这篇文章我们会：</p>\n<ol>\n<li>讨论image hashing/perceptual hashing(和为什么传统的hash不奏效)</li>\n<li>实现image hashing， 特别是difference hashing(dHash)</li>\n<li>使用image hashing来解决现实世界中的问题</li>\n</ol>\n<h3 id=\"step-#1:-将输入图像转化为灰度图\"><strong>Step #1: 将输入图像转化为灰度图</strong><a title=\"#step-#1:-将输入图像转化为灰度图\" href=\"#step-#1:-将输入图像转化为灰度图\"></a></h3>\n<p>我们image hashing算法的第一步是将输入的图像转化为灰度图，同时舍弃所有的颜色信息。</p>\n<p>舍弃颜色信息可以让我们：</p>\n<ol>\n<li>对图像进行hash的过程变得更快，因为我们只需要检测一个通道</li>\n<li>匹配那些相同但是颜色空间稍有出入的图像（因为颜色信息已经被我们去除了）</li>\n</ol>\n<p>如果无论如何你都对颜色特别感兴趣，你可以将image hashing 算法分别运用在每个通道上，然后最后将结果结合起来。（尽管这会导致三倍大的hash)</p>\n<h3 id=\"**step-#2:-修改原始图像的大小-**\">**Step #2: 修改原始图像的大小 **<a title=\"#**step-#2:-修改原始图像的大小-**\" href=\"#**step-#2:-修改原始图像的大小-**\"></a></h3>\n<p>由于我们的输入图像已经被转换成灰度图了，我们需要忽略横纵比，将它压缩到9×8的像素。对于大多数的图像和数据集来说，修改原始图片大小的步骤是这个算法最慢的一步。</p>\n<p>然而，现在的你可能有两个问题：</p>\n<ol>\n<li>我们在修改原始图像大小的时候为什么要忽略横纵比？</li>\n<li>为什么是9×8的像素——这似乎是一个很奇怪的大小？</li>\n</ol>\n<p>首先回答第一个问题：</p>\n<p>我们将图像压缩到9×8的大小同时忽略横纵比，是为了确保image hash的结果可以匹配相似的图像而不管它们初始的空间维度。</p>\n<p>第二个问题需要更多的解释，我们会在下一步进行解答。</p>\n<h3 id=\"**step-#3:-计算图片之间的差异-**\">**Step #3: 计算图片之间的差异 **<a title=\"#**step-#3:-计算图片之间的差异-**\" href=\"#**step-#3:-计算图片之间的差异-**\"></a></h3>\n<p>我们最后的目标是计算一个64-bit的hash——因为8×8=64，十分接近我们目标。</p>\n<p>因此，为什么要将图像的大小修改为9×8呢？</p>\n<p>请牢记我们需要实现算法的名字：<strong>difference hash</strong>。Difference hash算法通过计算相邻像素的差异而生效。</p>\n<p>如果我们使用一张每行有9个像素的图作为输入图像， 然后计算相邻列的像素，我们最后会得到8个不同结果。8行就会产生64个不同的结果，而这个结果也是我们希望编程的64位的hash.</p>\n<p>事实上，我们并不一定要计算差异——我们可以使用更好的方法来测试。</p>\n<p>如果你对这点仍有疑惑，不用担心， 一旦我们开始看一些代码之后，相信一切都会变得清晰起来。</p>\n<h3 id=\"**step-#4:-计算图片之间的差异-**\">**Step #4: 计算图片之间的差异 **<a title=\"#**step-#4:-计算图片之间的差异-**\" href=\"#**step-#4:-计算图片之间的差异-**\"></a></h3>\n","next":{"title":"OOP设计7大设计原则总结","link":"2020/04/09/OOP设计7大设计原则总结"},"plink":"https://musicpoet.top/2020/04/22/Image-hashing-with-OpenCV-and-Python/","toc":[{"id":"step-#1:-将输入图像转化为灰度图","title":"Step #1: 将输入图像转化为灰度图","index":"1"},{"id":"**step-#2:-修改原始图像的大小-**","title":"**Step #2: 修改原始图像的大小 **","index":"2"},{"id":"**step-#3:-计算图片之间的差异-**","title":"**Step #3: 计算图片之间的差异 **","index":"3"},{"id":"**step-#4:-计算图片之间的差异-**","title":"**Step #4: 计算图片之间的差异 **","index":"4"}],"copyright":{"custom":"转载请注明出处"}}