{"title":"Image hashing with OpenCV and Python","date":"2020-04-22T05:51:32.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"link":"2020/04/22/Image-hashing-with-OpenCV-and-Python","comments":true,"tags":["CV"],"categories":["图像处理"],"updated":"2020-04-22T05:51:32.000Z","content":"<blockquote>\n<p>写在前面：这篇文章摘自<strong>Adrian Rosebrock</strong>的一篇技术博客，这里只做简单的翻译总结。如果想直接看原文的话，可以点击以下链接查看：<a href=\"https://www.pyimagesearch.com/2017/11/27/image-hashing-opencv-python/\" target=\"_blank\">Image hashing with OpenCV and Python</a></p>\n</blockquote>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2020/04/9f118c121b0f31be.png\" alt=\"\" class=\"φcx\"></p>\n<p>Image hashing 或者 perceptual hashing 的过程包括：</p>\n<ol>\n<li>检测一张图像的内容</li>\n<li>根据输入图像的内容，为它创建一个特殊的hash值</li>\n</ol>\n<p>或许最出名的Image hashing 工具/服务是<a href=\"https://tineye.com/\" target=\"_blank\">TinEye</a>，它是一个逆向的图像搜索引擎。</p>\n<p>使用TinEye, 用户可以：</p>\n<ol>\n<li>上传一张图片</li>\n<li>TinEye会告诉用户网上这张图片的出处</li>\n</ol>\n<p>在这节的开头，你可以看到一个可视化的perceptual hashing/image hashing的例子。</p>\n<p>对于一张给定的输入图像，我们的算法会根据图像的视觉表现来计算图片的hash值。同时外观<strong>相似</strong>的图像，也应该有尽可能相似的hash值。（这里相似是指hash值之间的Hamming距离）</p>\n<p>通过使用image hashing 算法，我们可以在一定的时间内找到近似的图像。其中最差的情况是，我们需要遍历整个数据结构，时间复杂度是O(lg n)。</p>\n<p>这里做个提醒，通过这篇文章我们会：</p>\n<ol>\n<li>讨论image hashing/perceptual hashing(和为什么传统的hash不奏效)</li>\n<li>实现image hashing， 特别是difference hashing(dHash)</li>\n<li>使用image hashing来解决现实世界中的问题</li>\n</ol>\n<h3 id=\"step-#1:-将输入图像转化为灰度图\"><strong>Step #1: 将输入图像转化为灰度图</strong><a title=\"#step-#1:-将输入图像转化为灰度图\" href=\"#step-#1:-将输入图像转化为灰度图\"></a></h3>\n<p>我们image hashing算法的第一步是将输入的图像转化为灰度图，同时舍弃所有的颜色信息。</p>\n<p>舍弃颜色信息可以让我们：</p>\n<ol>\n<li>对图像进行hash的过程变得更快，因为我们只需要检测一个通道</li>\n<li>匹配那些相同但是颜色空间稍有出入的图像（因为颜色信息已经被我们去除了）</li>\n</ol>\n<p>如果无论如何你都对颜色特别感兴趣，你可以将image hashing 算法分别运用在每个通道上，然后最后将结果结合起来。（尽管这会导致三倍大的hash)</p>\n<h3 id=\"step-#2:-修改原始图像的大小\">Step #2: 修改原始图像的大小<a title=\"#step-#2:-修改原始图像的大小\" href=\"#step-#2:-修改原始图像的大小\"></a></h3>\n<p>由于我们的输入图像已经被转换成灰度图了，我们需要忽略横纵比，将它压缩到9×8的像素。对于大多数的图像和数据集来说，修改原始图片大小的步骤是这个算法最慢的一步。</p>\n<p>然而，现在的你可能有两个问题：</p>\n<ol>\n<li>我们在修改原始图像大小的时候为什么要忽略横纵比？</li>\n<li>为什么是9×8的像素——这似乎是一个很奇怪的大小？</li>\n</ol>\n<p>首先回答第一个问题：</p>\n<p>我们将图像压缩到9×8的大小同时忽略横纵比，是为了确保image hash的结果可以匹配相似的图像而不管它们初始的空间维度。</p>\n<p>第二个问题需要更多的解释，我们会在下一步进行解答。</p>\n<h3 id=\"step-#3:-计算图片之间的差异\">Step #3: 计算图片之间的差异<a title=\"#step-#3:-计算图片之间的差异\" href=\"#step-#3:-计算图片之间的差异\"></a></h3>\n<p>我们最后的目标是计算一个64-bit的hash——因为8×8=64，十分接近我们目标。</p>\n<p>因此，为什么要将图像的大小修改为9×8呢？</p>\n<p>请牢记我们需要实现算法的名字：<strong>difference hash</strong>。Difference hash算法通过计算相邻像素的差异而生效。</p>\n<p>如果我们使用一张每行有9个像素的图作为输入图像， 然后计算相邻列的像素，我们最后会得到8个不同结果。8行就会产生64个不同的结果，而这个结果也是我们希望编程的64位的hash.</p>\n<p>事实上，我们并不一定要计算差异——我们可以使用更好的方法来测试。</p>\n<p>如果你对这点仍有疑惑，不用担心， 一旦我们开始看一些代码之后，相信一切都会变得清晰起来。</p>\n<h3 id=\"step-#4:-建立hash\">Step #4: 建立hash<a title=\"#step-#4:-建立hash\" href=\"#step-#4:-建立hash\"></a></h3>\n<p>最后一步是分配bit值按后建立结果hash。为了实现这个目标，我们使用一个简单的二分类测试。</p>\n<p>给定一张差异图像D，设其对应的像素为P，我们使用下面的测试：<code>P[X] &gt; P[X + 1] = 1 else 0</code>。</p>\n<p>在这个例子中，我们测试左边的像素是不是比右边的像素更亮。如果左边像素更亮的话，我们就将输出值设为1。否则，如果左边的像素更暗的话，我们就将输出值设为0.</p>\n<p>输出的图像如下图所示。</p>\n<p><img src=\"https://ftp.bmp.ovh/imgs/2020/04/95be7a7393327c8e.png\" alt=\"\" class=\"φcx\"></p>\n<h3 id=\"使用difference-hash的好处\">使用Difference hash的好处<a title=\"#使用difference-hash的好处\" href=\"#使用difference-hash的好处\"></a></h3>\n<p>使用difference hash 有很多好处，主要包含以下几点：</p>\n<ol>\n<li>如果我们输入图像的横纵比改变的话，我们的image hash也不会改变</li>\n<li>调整亮度或者对比度：1)不会改变我们的hash值 2）或者只是有轻微改变，以确保hash值彼此尽可能贴近</li>\n<li>Difference hash非常快</li>\n</ol>\n<p><em>以下是代码部分：</em></p>\n<figure class=\"highlight xl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># <span class=\"keyword\">import</span> the necessary packages</span><br><span class=\"line\">from imutils <span class=\"keyword\">import</span> paths</span><br><span class=\"line\"><span class=\"keyword\">import</span> argparse</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"built_in\">time</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> sys</span><br><span class=\"line\"><span class=\"keyword\">import</span> cv2</span><br><span class=\"line\"><span class=\"keyword\">import</span> os</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ruby\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># define the difference hash function </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">dhash</span><span class=\"params\">(image, hashSize=<span class=\"number\">8</span>)</span></span><span class=\"symbol\">:</span></span><br><span class=\"line\">\t<span class=\"comment\"># resize the input image, adding a single column (width) so we</span></span><br><span class=\"line\">\t<span class=\"comment\"># can compute the horizontal gradient</span></span><br><span class=\"line\">\tresized = cv2.resize(image, (hashSize + <span class=\"number\">1</span>, hashSize))</span><br><span class=\"line\">\t<span class=\"comment\"># compute the (relative) horizontal gradient between adjacent</span></span><br><span class=\"line\">\t<span class=\"comment\"># column pixels</span></span><br><span class=\"line\">\tdiff = resized[<span class=\"symbol\">:</span>, <span class=\"number\">1</span><span class=\"symbol\">:</span>] &gt; resized[<span class=\"symbol\">:</span>, <span class=\"symbol\">:-</span><span class=\"number\">1</span>]</span><br><span class=\"line\">\t<span class=\"comment\"># convert the difference image to a hash</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> sum([<span class=\"number\">2</span> ** i <span class=\"keyword\">for</span> (i, v) <span class=\"keyword\">in</span> enumerate(diff.flatten()) <span class=\"keyword\">if</span> v])</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># construct the argument parse and parse the arguments</span></span><br><span class=\"line\">ap = argparse.ArgumentParser()</span><br><span class=\"line\">ap.add_argument(<span class=\"string\">\"-a\"</span>, <span class=\"string\">\"--haystack\"</span>, <span class=\"attribute\">required</span>=<span class=\"literal\">True</span>,</span><br><span class=\"line\">\t<span class=\"attribute\">help</span>=<span class=\"string\">\"dataset of images to search through (i.e., the haytack)\"</span>)</span><br><span class=\"line\">ap.add_argument(<span class=\"string\">\"-n\"</span>, <span class=\"string\">\"--needles\"</span>, <span class=\"attribute\">required</span>=<span class=\"literal\">True</span>,</span><br><span class=\"line\">\t<span class=\"attribute\">help</span>=<span class=\"string\">\"set of images we are searching for (i.e., needles)\"</span>)</span><br><span class=\"line\">args = vars(ap.parse_args())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight nix\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># grab the paths to both the haystack and needle images </span></span><br><span class=\"line\">print(<span class=\"string\">\"[INFO] computing hashes for haystack...\"</span>)</span><br><span class=\"line\"><span class=\"attr\">haystackPaths</span> = list(paths.list_images(args[<span class=\"string\">\"haystack\"</span>]))</span><br><span class=\"line\"><span class=\"attr\">needlePaths</span> = list(paths.list_images(args[<span class=\"string\">\"needles\"</span>]))</span><br><span class=\"line\"><span class=\"comment\"># remove the `\\` character from any filenames containing a space</span></span><br><span class=\"line\"><span class=\"comment\"># (assuming you're executing the code on a Unix machine)</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> sys.platform != <span class=\"string\">\"win32\"</span>:</span><br><span class=\"line\">\t<span class=\"attr\">haystackPaths</span> = [p.replace(<span class=\"string\">\"\\\\\"</span>, <span class=\"string\">\"\"</span>) for p <span class=\"keyword\">in</span> haystackPaths]</span><br><span class=\"line\">\t<span class=\"attr\">needlePaths</span> = [p.replace(<span class=\"string\">\"\\\\\"</span>, <span class=\"string\">\"\"</span>) for p <span class=\"keyword\">in</span> needlePaths]</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># grab the base subdirectories for the needle paths, initialize the</span></span><br><span class=\"line\"><span class=\"comment\"># dictionary that will map the image hash to corresponding image,</span></span><br><span class=\"line\"><span class=\"comment\"># hashes, then start the timer</span></span><br><span class=\"line\"><span class=\"attr\">BASE_PATHS</span> = set([p.split(os.path.sep)[-<span class=\"number\">2</span>] for p in needlePaths])</span><br><span class=\"line\"><span class=\"attr\">haystack</span> = &#123;&#125;</span><br><span class=\"line\"><span class=\"attr\">start</span> = time.time()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># loop over the haystack paths</span></span><br><span class=\"line\"><span class=\"attr\">for</span> <span class=\"string\">p in haystackPaths:</span></span><br><span class=\"line\"><span class=\"comment\">\t# load the image from disk</span></span><br><span class=\"line\">\t<span class=\"attr\">image</span> = <span class=\"string\">cv2.imread(p)</span></span><br><span class=\"line\"><span class=\"comment\">\t# if the image is None then we could not load it from disk (so</span></span><br><span class=\"line\"><span class=\"comment\">\t# skip it)</span></span><br><span class=\"line\">\t<span class=\"attr\">if</span> <span class=\"string\">image is None:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">continue</span></span><br><span class=\"line\"><span class=\"comment\">\t# convert the image to grayscale and compute the hash</span></span><br><span class=\"line\">\t<span class=\"attr\">image</span> = <span class=\"string\">cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span></span><br><span class=\"line\">\t<span class=\"attr\">imageHash</span> = <span class=\"string\">dhash(image)</span></span><br><span class=\"line\"><span class=\"comment\">\t# update the haystack dictionary</span></span><br><span class=\"line\">\t<span class=\"attr\">l</span> = <span class=\"string\">haystack.get(imageHash, [])</span></span><br><span class=\"line\">\t<span class=\"attr\">l.append(p)</span></span><br><span class=\"line\">\t<span class=\"meta\">haystack[imageHash]</span> = <span class=\"string\">l</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight gauss\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\"># show timing for hashing haystack images, then start computing the</span></span><br><span class=\"line\"><span class=\"meta\"># hashes for needle images</span></span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"string\">\"[INFO] processed &#123;&#125; images in &#123;:.2f&#125; seconds\"</span>.<span class=\"keyword\">format</span>(</span><br><span class=\"line\">\t<span class=\"built_in\">len</span>(haystack), <span class=\"built_in\">time</span>.<span class=\"built_in\">time</span>() - start))</span><br><span class=\"line\"><span class=\"keyword\">print</span>(<span class=\"string\">\"[INFO] computing hashes for needles...\"</span>)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight properties\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># loop over the needle paths</span></span><br><span class=\"line\"><span class=\"attr\">for</span> <span class=\"string\">p in needlePaths:</span></span><br><span class=\"line\"><span class=\"comment\">\t# load the image from disk</span></span><br><span class=\"line\">\t<span class=\"attr\">image</span> = <span class=\"string\">cv2.imread(p)</span></span><br><span class=\"line\"><span class=\"comment\">\t# if the image is None then we could not load it from disk (so</span></span><br><span class=\"line\"><span class=\"comment\">\t# skip it)</span></span><br><span class=\"line\">\t<span class=\"attr\">if</span> <span class=\"string\">image is None:</span></span><br><span class=\"line\">\t\t<span class=\"attr\">continue</span></span><br><span class=\"line\"><span class=\"comment\">\t# convert the image to grayscale and compute the hash</span></span><br><span class=\"line\">\t<span class=\"attr\">image</span> = <span class=\"string\">cv2.cvtColor(image, cv2.COLOR_BGR2GRAY)</span></span><br><span class=\"line\">\t<span class=\"attr\">imageHash</span> = <span class=\"string\">dhash(image)</span></span><br><span class=\"line\"><span class=\"comment\">\t# grab all image paths that match the hash</span></span><br><span class=\"line\">\t<span class=\"attr\">matchedPaths</span> = <span class=\"string\">haystack.get(imageHash, [])</span></span><br><span class=\"line\"><span class=\"comment\">\t# loop over all matched paths</span></span><br><span class=\"line\">\t<span class=\"attr\">for</span> <span class=\"string\">matchedPath in matchedPaths:</span></span><br><span class=\"line\"><span class=\"comment\">\t\t# extract the subdirectory from the image path</span></span><br><span class=\"line\">\t\t<span class=\"attr\">b</span> = <span class=\"string\">p.split(os.path.sep)[-2]</span></span><br><span class=\"line\"><span class=\"comment\">\t\t# if the subdirectory exists in the base path for the needle</span></span><br><span class=\"line\"><span class=\"comment\">\t\t# images, remove it</span></span><br><span class=\"line\">\t\t<span class=\"attr\">if</span> <span class=\"string\">b in BASE_PATHS:</span></span><br><span class=\"line\">\t\t\t<span class=\"attr\">BASE_PATHS.remove(b)</span></span><br></pre></td></tr></table></figure>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># display directories to check</span></span><br><span class=\"line\"><span class=\"builtin-name\">print</span>(<span class=\"string\">\"[INFO] check the following directories...\"</span>)</span><br><span class=\"line\"><span class=\"comment\"># loop over each subdirectory and display it</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> b <span class=\"keyword\">in</span> BASE_PATHS:</span><br><span class=\"line\">\t<span class=\"builtin-name\">print</span>(<span class=\"string\">\"[INFO] &#123;&#125;\"</span>.format(b))</span><br></pre></td></tr></table></figure>\n","prev":{"title":"Keras学习之Model方法","link":"2020/04/27/Keras学习之Model方法"},"next":{"title":"OOP设计7大设计原则总结","link":"2020/04/09/OOP设计7大设计原则总结"},"plink":"https://musicpoet.top/2020/04/22/Image-hashing-with-OpenCV-and-Python/","toc":[{"id":"step-#1:-将输入图像转化为灰度图","title":"Step #1: 将输入图像转化为灰度图","index":"1"},{"id":"step-#2:-修改原始图像的大小","title":"Step #2: 修改原始图像的大小","index":"2"},{"id":"step-#3:-计算图片之间的差异","title":"Step #3: 计算图片之间的差异","index":"3"},{"id":"step-#4:-建立hash","title":"Step #4: 建立hash","index":"4"},{"id":"使用difference-hash的好处","title":"使用Difference hash的好处","index":"5"}],"copyright":{"custom":"转载请注明出处"}}