{"title":"OOP设计7大设计原则总结","date":"2020-04-09T09:07:24.000Z","date_formatted":{"ll":"2020年4月9日","L":"2020/04/09","MM-DD":"04-09"},"link":"2020/04/09/OOP设计7大设计原则总结","comments":true,"tags":["设计模式"],"categories":["软件体系结构与设计模式"],"updated":"2020-04-09T09:07:24.000Z","content":"<p>在软件开发中，为了提高软件系统的可维护性和可复用性，增加软件的可扩展性和灵活性，程序员要尽量根据 7 条原则来开发程序，从而提高软件开发效率、节约软件开发成本和维护成本。下面将为你依次介绍这7条开发原则。</p>\n<h2 id=\"一.-开闭原则\">一. 开闭原则<a title=\"#一.-开闭原则\" href=\"#一.-开闭原则\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义\">定义<a title=\"#定义\" href=\"#定义\"></a></h3>\n<p>软件实体应当对扩展开放，对修改关闭。当应用需求改变时，在不修改软件实体源代码或者二进制代码的前提下，可以扩展模块的功能，使其满足新的需求。</p>\n</li>\n<li>\n<h3 id=\"作用\">作用<a title=\"#作用\" href=\"#作用\"></a></h3>\n<ul>\n<li>\n<p>对软件测试的影响。软件遵循开闭原则的话，软件测试只需要对扩展的代码进行测试就好了，因为原来的测试代码可以正常运行。</p>\n</li>\n<li>\n<p>可以提高代码的可复用性。粒度越小，被复用的可能性就越大；在面向对象的程序设计中，根据原子和抽象编程可以提高代码的可复用性。</p>\n</li>\n<li>\n<p>可以提高代码的可维护性。遵循开闭原则的软件，其稳定性高和延续性强，从而易于扩展和维护。</p>\n</li>\n</ul>\n</li>\n<li>\n<h3 id=\"实现方法\">实现方法<a title=\"#实现方法\" href=\"#实现方法\"></a></h3>\n<p>可以通过“抽象约束、封装变化”来实现开闭原则。即通过接口或者抽象类为软件实体定义一个相对稳定的抽象层，从而将相同的可变因素封装在相同的具体实现类中。</p>\n<p>因为抽象灵活性好、适应性广，只要抽象地合理，可以基本保持软件架构的稳定。而软件中容易改变的细节可以从抽象派生的实现类来进行扩展，当软件需要发生变化时，只需要根据需求重新派生一个实现类来扩展就可以了。</p>\n</li>\n</ol>\n<h2 id=\"二.里氏代换原则（lsp原则）\">二.里氏代换原则（LSP原则）<a title=\"#二.里氏代换原则（lsp原则）\" href=\"#二.里氏代换原则（lsp原则）\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-1\">定义<a title=\"#定义-1\" href=\"#定义-1\"></a></h3>\n<p>继承必须确保超类所拥有的性质在子类中仍然成立。它是继承复用的基础，也反映了基类与子类之间的关系，是对开闭原则的补充，是对实现抽象化的具体步骤的规范。</p>\n</li>\n<li>\n<h3 id=\"作用-1\">作用<a title=\"#作用-1\" href=\"#作用-1\"></a></h3>\n<ul>\n<li>里氏替换原则是实现开闭原则的重要方式之一。</li>\n<li>它克服了继承中重写父类造成的可复用性变差的缺点。</li>\n<li>它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"实现方法-1\">实现方法<a title=\"#实现方法-1\" href=\"#实现方法-1\"></a></h3>\n<p>里氏替换原则通俗来说就是：**子类可以扩展父类的功能，但是不能改变父类原有的功能。**子类继承父类时，除了添加新的方法完成新增的功能外，尽量不要重写父类的方法。</p>\n<p>如果通过重写父类的方法来完成新的功能，这样写起来虽然简单，但是整个继承体系的复用性会变差，特别是运行多态比较频繁时，程序运行出错的概率会非常大。</p>\n<p>如果程序违背了里氏替换原则，继承类的对象在基类出现的地方那个会出现运行错误。<strong>修正方法是：取消原来的继承关系，重新设计它们之间的关系。</strong></p>\n</li>\n</ol>\n<h2 id=\"三.-依赖倒置原则\">三. 依赖倒置原则<a title=\"#三.-依赖倒置原则\" href=\"#三.-依赖倒置原则\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-2\">定义<a title=\"#定义-2\" href=\"#定义-2\"></a></h3>\n<p>高层模块不应该依赖低层模块，两者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>\n<p><strong>核心思想：要面向接口编程，不要面向实现编程。</strong></p>\n<p>依赖倒置原则是实现开闭原则的重要途径之一，它降低了客户与实现模块之间的耦合。而使用接口或者抽象类的目的是制定好规范和契约，而不去涉及任何具体的操作，把展现细节的任务交给它们的实现类去完成。</p>\n</li>\n<li>\n<h3 id=\"作用-2\">作用<a title=\"#作用-2\" href=\"#作用-2\"></a></h3>\n<ul>\n<li>可以降低类之间的耦合性。</li>\n<li>可以提高系统的稳定性。</li>\n<li>可以减少并行开发引起的风险。</li>\n<li>可以提高代码的可读性和可维护性。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"实现方法-2\">实现方法<a title=\"#实现方法-2\" href=\"#实现方法-2\"></a></h3>\n<p>我们在具体编程中只要遵循以下4点，就能在项目中满足这个规则：</p>\n<ul>\n<li>每个类尽量提供接口或抽象类，或者两者都具备。</li>\n<li>变量的声明类型尽量是接口或者抽象类。</li>\n<li>任何类都不应该从具体类派生。</li>\n<li>使用继承时尽量遵循里氏替换原则。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"四.-单一职责原则\">四. 单一职责原则<a title=\"#四.-单一职责原则\" href=\"#四.-单一职责原则\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-3\">定义<a title=\"#定义-3\" href=\"#定义-3\"></a></h3>\n<p><strong>一个类应该有且仅有一个引起它变化的原因，否则类应该被拆分。</strong></p>\n<p>该原则提出对象不应该承担太多职责，如果一个对象承担太多的职责，至少会有以下两个缺点：</p>\n<ul>\n<li>一个职责的变化可能会削弱或者抑制这个类实现其他职责的能力。</li>\n<li>当客户端需要该对象的某一个职责时，不得不将其他不需要的职责全都包含进来，从而造成冗余代码或代码的浪费。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"作用-3\">作用<a title=\"#作用-3\" href=\"#作用-3\"></a></h3>\n<ul>\n<li>降低类的复杂度。一个类只负责一项职责，其逻辑肯定要比负责多项职责简单得多。</li>\n<li>提高类的可读性。复杂性降低，自然其可读性会提高。</li>\n<li>提高系统的可维护性。可读性提高，那自然更容易维护了。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"实现方法-3\">实现方法<a title=\"#实现方法-3\" href=\"#实现方法-3\"></a></h3>\n<p>单一职责原则是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，再封装到不同的类或模块中。而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</p>\n</li>\n</ol>\n<h2 id=\"五.接口隔离原则(isp)\">五.接口隔离原则(ISP)<a title=\"#五.接口隔离原则(isp)\" href=\"#五.接口隔离原则(isp)\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-4\">定义<a title=\"#定义-4\" href=\"#定义-4\"></a></h3>\n<p>程序员应尽量将臃肿庞大的接口拆分成更小和更具体的接口，让接口只包含客户感兴趣的方法。<strong>一个类对另一个类的依赖应该建立在最小的接口之上。</strong></p>\n</li>\n<li>\n<h3 id=\"接口隔离原则和单一职责原则的区别\">接口隔离原则和单一职责原则的区别<a title=\"#接口隔离原则和单一职责原则的区别\" href=\"#接口隔离原则和单一职责原则的区别\"></a></h3>\n<ul>\n<li>单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。</li>\n<li>单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要是约束接口，主要针对抽象和程序整体框架的构建。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"作用-4\">作用<a title=\"#作用-4\" href=\"#作用-4\"></a></h3>\n<ul>\n<li>将臃肿庞大的接口分解为多个粒度小的接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。</li>\n<li>接口隔离提高了系统的内聚性，减少了对外交互，降低了系统的耦合性。</li>\n<li>如果接口的粒度大小定义合理，能够保证系统的稳定性；但是，<strong>如果定义过小，则会造成接口数量过多，使设计复杂化；如果定义太大，灵活性降低，无法提供定制服务，给整体项目带来无法预料的风险。</strong></li>\n<li>使用多个专门的接口还能够体现对象的层次，因为可以通过接口的继承，实现对总接口的定义。</li>\n<li>能减少项目工程中的代码冗余。</li>\n</ul>\n</li>\n<li>\n<h3 id=\"实现方法-4\">实现方法<a title=\"#实现方法-4\" href=\"#实现方法-4\"></a></h3>\n<ul>\n<li>接口尽量小，但是要有限度。一个接口只服务于一个子模块或业务逻辑。</li>\n<li>为依赖接口的类定制服务。只提供调用者需要的方法，屏蔽不需要的方法。</li>\n<li>了解环境，拒绝盲从。每个项目或产品都有选定的环境因素，环境不同，接口拆分的标准就不同深入了解业务逻辑。</li>\n<li>提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"六.迪米特法则\">六.迪米特法则<a title=\"#六.迪米特法则\" href=\"#六.迪米特法则\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-5\">定义<a title=\"#定义-5\" href=\"#定义-5\"></a></h3>\n<p><strong>只与你“直接朋友”交谈，不跟“陌生人”说话。</strong></p>\n<p>迪米特法则中的“朋友”是指：当前对象本身、当前对象的成员对象、当前对象所创建的对象、当前对象的方法参数等，这些对象同当前对象存在关联、聚合或组合关系，可以直接访问这些对象的方法。</p>\n<p>如果两个软件实体无需直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合度，提高模块的相对独立性。</p>\n</li>\n<li>\n<h3 id=\"作用-5\">作用<a title=\"#作用-5\" href=\"#作用-5\"></a></h3>\n<ul>\n<li>\n<p>降低了类之间的耦合度，提高了模块的相对独立性。</p>\n</li>\n<li>\n<p>由于亲合度降低，从而提高了类的可复用率和系统的扩展性。</p>\n</li>\n</ul>\n<p><em>注：过度使用迪米特法则会使系统产生大量的中介类，从而增加系统的复杂性，使模块之间的通信效率降低。</em></p>\n</li>\n<li>\n<h3 id=\"实现方法-5\">实现方法<a title=\"#实现方法-5\" href=\"#实现方法-5\"></a></h3>\n<ul>\n<li>\n<p>从依赖者的角度来说，只依赖应该依赖的对象。</p>\n</li>\n<li>\n<p>从被依赖者的角度说，只暴露应该暴露的方法。</p>\n</li>\n</ul>\n</li>\n<li>\n<h3 id=\"使用迪米特法则应注意的点\">使用迪米特法则应注意的点<a title=\"#使用迪米特法则应注意的点\" href=\"#使用迪米特法则应注意的点\"></a></h3>\n<ul>\n<li>\n<p>在类的划分上，应该创建弱耦合的类。类与类之间的耦合越弱，就越有利于实现可复用的目标。</p>\n</li>\n<li>\n<p>在类的结构设计上，尽量降低类成员的访问权限。</p>\n</li>\n<li>\n<p>在类的设计上，优先考虑将一个类设置成不变类。</p>\n</li>\n<li>\n<p>在对其他类的引用上，将引用其他对象的次数降到最低。</p>\n</li>\n<li>\n<p>不暴露类的属性成员，而应该提供相应的访问器（set 和 get 方法）。</p>\n</li>\n<li>\n<p>谨慎使用序列化（Serializable）功能。</p>\n</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"七.合成复用原则(crp)\">七.合成复用原则(CRP)<a title=\"#七.合成复用原则(crp)\" href=\"#七.合成复用原则(crp)\"></a></h2>\n<ol>\n<li>\n<h3 id=\"定义-6\">定义<a title=\"#定义-6\" href=\"#定义-6\"></a></h3>\n<p>在软件复用时，要尽量先使用组合或者聚合等关联关系来实现，其次才考虑使用继承关系来实现。<strong>如果要使用继承关系，必须得严格遵循里氏替换原则。</strong></p>\n</li>\n<li>\n<h3 id=\"作用及重要性\">作用及重要性<a title=\"#作用及重要性\" href=\"#作用及重要性\"></a></h3>\n<p>通常类的复用分为继承复用和合成复用两种。继承复用虽然简单易实现，但是它也有很多缺点：</p>\n<ul>\n<li>\n<p>继承复用破坏了类的封装性。因为继承会将父类的实现细节暴露给子类，父类对子类是透明的，所以这种复用又称为“白箱”复用。</p>\n</li>\n<li>\n<p>子类与父类的耦合度高。父类的实现的任何改变都会导致子类的实现发生变化，这不利于类的扩展与维护。</p>\n</li>\n<li>\n<p>它限制了复用的灵活性。从父类继承而来的实现是静态的，在编译时已经定义，所以在运行时不可能发生变化。</p>\n</li>\n</ul>\n<p>采用组合或者聚合复用时，则可避免这些缺点，同时也具备以下优点：</p>\n<ul>\n<li>维持了类的封装性。因为成分对象的内部细节是新对象看不见的，所以这种复用又称为“黑箱”复用。</li>\n<li>新旧类之间的耦合度低。这种复用所需的依赖较少，新对象存取成分对象的唯一方法是通过成分对象的接口。</li>\n<li>复用的灵活性高。这种复用可以在运行时动态进行，新对象可以动态地引用与成分对象类型相同的对象。</li>\n</ul>\n<h3 id=\"3.实现方法\">3.实现方法<a title=\"#3.实现方法\" href=\"#3.实现方法\"></a></h3>\n<p>通过将已有的对象纳入新对象中，作为新对象的成员对象来实现的，新对象可以调用已有对象的功能，从而达到复用。</p>\n</li>\n</ol>\n<h2 id=\"八.总结\">八.总结<a title=\"#八.总结\" href=\"#八.总结\"></a></h2>\n<p>以上介绍的7种设计原则是软件设计模式必须遵循的原则，各种原则要求的侧重点不同。</p>\n<ul>\n<li>\n<p>开闭原则是总纲，它告诉我们要对扩展开放，对修改关闭。</p>\n</li>\n<li>\n<p>里氏替换原则告诉我们不要破坏继承体系。</p>\n</li>\n<li>\n<p>依赖倒置原则告诉我们要面向接口编程。</p>\n</li>\n<li>\n<p>单一职责原则告诉我们实现类要职责单一。</p>\n</li>\n<li>\n<p>接口隔离原则告诉我们在设计接口的时候要精简单一。</p>\n</li>\n<li>\n<p>迪米特法则告诉我们要降低耦合度。</p>\n</li>\n<li>\n<p>合成复用原则告诉我们要优先使用组合或者聚合关系复用，少用继承关系复用。</p>\n</li>\n</ul>\n<hr>\n<p>以上内容整理自 <a href=\"http://c.biancheng.net/design_pattern/\" target=\"_blank\">C语言中文网 </a>，感谢你的阅读。</p>\n","plink":"https://musicpoet.top/2020/04/09/OOP设计7大设计原则总结/","copyright":{"custom":"转载请注明出处"}}